/*Binary search tree
  1. Insert elements in a tree
  2. Find a specific element in tree
  3. Display all elements of tree
  4. Delete an element in tree
*/
#include<iostream>
using namespace std;

struct node
{
	int data;
	node* left;
	node* right;
};

class bst
{
	public:
		node * root;
		void insert(node *,node *);
		void display(node *,int level);
		void find(node *,int item);
		void deleteNode(int item);
		void findDelNode(int item,node **parent,node **location);
		void case_a(node *location,node *parent);
		void case_b(node *location,node *parent);
		void case_c(node *location,node *parent);
		bst()
		{
			root=NULL;
		}
};

int main()
{		
		int option,findElement,delElement;
		bst bstPtr;
		node *addNode;
	
		while(1)
		{
				cout<<"Choose options"<<endl;
				cout<<"1. Enter the element in tree"<<endl;
				cout<<"2. Display"<<endl;
				cout<<"3. Find an element"<<endl;
				cout<<"4. Delete an element"<<endl;
				cout<<"5. Quit"<<endl;
				cin>>option;
			switch(option)
			{
			
				case 1:		addNode=new node();
							cout<<"Insert element in tree"<<endl;
							cin>>addNode->data;
							bstPtr.insert(bstPtr.root,addNode);
							break;
				case 2:		bstPtr.display(bstPtr.root,1);
							break;
				case 3:		cout<<"Enter which element to find"<<endl;
							cin>>findElement;
							bstPtr.find(bstPtr.root,findElement);
							break;
				case 4:		cout<<"Enter which element to delete"<<endl;
							cin>>delElement;
							bstPtr.deleteNode(delElement);
							break;
				case 5:     exit(1);
				
			}
		}
}
void bst::display(node *temp ,int level)
{
	if(temp!=NULL)
	{
		display(temp->right,level+1);
		cout<<endl;
		if(temp==root)
		{
				cout<<"Root->";			
		}
		else
		{
			for(int i=0;i<level;i++)
			{
				cout<<"      ";
			}
		}
		cout<<temp->data;
		cout<<endl;
		display(temp->left,level+1);
	}
}

void bst::insert(node *temp ,node *addNode)
{ 	
	if(root==NULL)
	{	
	//	root=new node;
		root=addNode;
		root->data=addNode->data;
		root->left=NULL;
		root->right=NULL;
		cout<<"root node added"<<root->data<<endl;
		return;
	}

	if(temp->data > addNode->data)
	{
		if(temp->left==NULL)
		{   cout<<"temp->left is NULL"<<endl;
		
			temp->left=addNode;
			temp->left->data=addNode->data;
			temp->left->left=NULL;
			temp->left->right=NULL;
		
		}
		else
		{			
		    cout<<"temp->left is not NULL"<<endl;
			
			insert(temp->left,addNode);
		}
	   
	}
	else
	{
		if(temp->right==NULL)
		{   cout<<"temp->right is NULL"<<endl;
		
			temp->right=addNode;
			temp->right->data=addNode->data;
			temp->right->left=NULL;
			temp->right->right=NULL;		
		}
		else
		{
			insert(temp->right,addNode);
		}

	}
	
	return;
}
void bst::find(node *temp,int item)
{	
	node *ptr;
	if(root ==NULL)
	{	
		return;
	}
	
	if(item > temp->data)
	{
		ptr=temp->right;	
	}
	else
	{
		ptr=temp->left;	
	}

	while(ptr!=NULL)
	{
		if(item == ptr->data)
		{
			cout<<"Item found"<<ptr->data<<endl;
		}
		else
		{
			cout<<"Item not found"<<endl;
		}

		if(item > ptr->data)
		{
			ptr=ptr->right;
		}
		else
		{
			ptr=ptr->left;
		}
	}
}
void bst::deleteNode(int item)
{
	
	if(root ==NULL)
	{
		cout<<"Tree is empty"<<endl;
	}
	node *parent;
	node *location;
	findDelNode(item,&parent,&location);
	cout<<"delete"<<parent->data<<"location"<<location->data<<endl;

	if(location->left ==NULL && location->right==NULL)
		case_a(location,parent);	
	else if(location->right!=NULL && location->left==NULL)
		case_b(location,parent);
	else if(location->left!=NULL && location->right==NULL)
		case_b(location,parent);
	else
		case_c(location,parent);
	
}

void bst::findDelNode(int item, node **parent, node **location)
{
	node *ptr;
	node *ptrSave;
	if(root == NULL)
	{
		parent=NULL;
		location=NULL;
	}
	if(item ==root->data)
	{
		*location=root;
		*parent=NULL;
	}
	if(item > root->data)
	{
		ptr=root->right;
	}
	else
	{	
		ptr=root->left;
	}
	ptrSave=root;
	while(ptr!=NULL)
	{
		if(item ==ptr->data)
		{
			*location=ptr;
			*parent=ptrSave;
			return;
		}
		ptrSave=ptr;
		if(item > ptr->data)
		{
			ptr=ptr->right;
		}
		else
		{
			ptr=ptr->left;
		}
	}
	*location=NULL;
	*parent=ptrSave;
}
void bst::case_a(node *location,node *parent)
{
	cout<<"casea"<<location->data<<endl;
	if(location == parent->left)
	{
		parent->left=NULL;		
	}
	else
		parent->right=NULL;
}
void bst::case_b(node *location,node *parent)
{
	node *child;
	cout<<"caseb"<<location->data<<parent->data<<endl;
	if(location->left!=NULL)
		child=location->left;
	else
		child=location->right;

	if(parent->left == location)
		parent->left=child;
	else
		parent->right=child;
}
void bst::case_c(node *location,node *parent)
{
	cout<<"casec"<<location->data<<parent->data<<endl;
	node *ptr;
	node *ptrParent;
	node *ptrMin,*ptrParentSave;
	ptr=location->right;

	while(ptr->left!=NULL)
	{
		ptrParent=ptr;
		ptr=ptr->left;
	}
	ptrMin=ptr;
	ptrParentSave=ptrParent;
	//Swap the node to be deleted with the smallest node from the right subtree
	int temp;
	temp=location->data;
	location->data=ptrMin->data;
	ptrMin->data=temp;

	if(ptrMin->left==NULL && ptrMin->right==NULL)
		case_a(ptrMin,ptrParentSave);//Pass the node to be deleted and its parent
	else
		case_b(ptrMin,ptrParentSave);

	cout<<"casec"<<location->data<<ptrMin->data<<ptrParentSave->data<<endl;
}
